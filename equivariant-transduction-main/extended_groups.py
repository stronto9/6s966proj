import torch
from math import factorial
from itertools import permutations

class PermutationSubgroup(object):
    """
    General base class for subgroups of a permutation group
    """

    def __init__(self, n, p, device):
        self.device = device
        self.n = n
        self.p = p
    
    def __len__(self):
        raise NotImplementedError
    
    def get_element(self, i):
        """
        Returns the element of the subgroup indexed by i
        """
        raise NotImplementedError
    
    def act(self, i, x):
        """
        Act on x with g = a^i
        """
        g = self.get_element(i).unsqueeze(0).unsqueeze(0).repeat(x.shape[0], 
            x.shape[1], 1, 1)
        g = self.fix_shape(g, x)
        return torch.matmul(g, x)
    
    def act_inverse(self, i, x):
        """
        Act on x with g = a^{-i}
        """
        g = self.get_inverse(i).unsqueeze(0).unsqueeze(0).repeat(x.shape[0], 
            x.shape[1], 1, 1)
        g = self.fix_shape(g, x)
        return torch.matmul(g, x)
    
    def fix_shape(self, g, x):
        """
        Ensures tensors are correct size for multiplication.
        """
        if x.shape[2] < self.n and x.shape[2] >= self.p:
            g = g[:, :, :x.shape[2],: x.shape[2]]
        elif x.shape[2] > self.n:
            new_g = torch.zeros((g.shape[0], g.shape[1], x.shape[2], 
                x.shape[2])).to(self.device)
            new_g[:, :, :g.shape[2], :g.shape[3]] = g
            new_g[:, :, g.shape[2]:, g.shape[3]:] = torch.eye(
                x.shape[2] - self.n)
            g = new_g
        return g


class CyclicPermutationGroup(PermutationSubgroup):
    """
    Cyclic permutation group, a subgroup of S_n, generated by the 
    permutation (123...p), i.e. where only cyclic shifts of the first p 
    elements occur.
    """
    def __init__(self, n, p, device):
        super(CyclicPermutationGroup, self).__init__(n, p, device)
        self.cache = [None for i in range(self.p)]
        self.device = device
    
    def __len__(self):
        return self.p

    def get_element(self, i):
        """
        Returns g = a^i where a = (12...p) is the generator of the group
        """
        if self.cache[i] is not None:
            return self.cache[i]
        g = torch.zeros((self.n, self.n)).to(self.device)
        for j in range(self.p):
            g[(j + i) % self.p, j] = 1
        for j in range(self.p, self.n):
            g[j, j] = 1
        if self.cache[i] is None:
            self.cache[i] = g
        return g

    def get_inverse(self, i):
        """
        Returns inverse of g=a^i, i.e. a^(p - i)
        """
        return self.get_element((self.p - i) % self.p)

class SymmetricGroup(PermutationSubgroup):

    def __init__(self, n, p, device):
        super(SymmetricGroup, self).__init__(n, p, device)
        self.perms = permutations(range(p))
        self.len = factorial(p)

        for perm in permutations(range(p)):
            pm = torch.zeros((n, n), device=self.device)
            for i, j in enumerate(perm):
                pm[i, j] = 1
            for j in range(p, n):
                pm[j, j] = 1
            self.matrices.append(pm)
    
    def __len__(self):
        return self.len
    
    def get_element(self, i):
        
        out = torch.zeros((self.n, self.n), device=self.device)
        for j, k in enumerate(self.perms[i]):
            out[j, k] = 1
        for j in range(self.p, self.n):
            out[j, j] = 1
        return out
    
    def get_inverse(self, i):
        return torch.pinverse(self.get_element(i))


class AlternatingGroup(PermutationSubgroup):

    def __init__(self, n, p, device):
        super(AlternatingGroup, self).__init__(n, p, device)
        self.perms = []
        self.len = factorial(p)//2


        for perm in permutations(range(p)):
            pm = torch.zeros((n, n), device=self.device)
            for i, j in enumerate(perm):
                pm[i, j] = 1
            for j in range(p, n):
                pm[j, j] = 1
            if torch.linalg.det(pm) == 1:
                self.perms.append(perm)
            del pm

    def __len__(self):
        return self.len

    def get_element(self, i):
        out = torch.zeros((self.n, self.n), device=self.device)
        for j, k in enumerate(self.perms[i]):
            out[j, k] = 1
        for j in range(self.p, self.n):
            out[j, j] = 1
        return out
    
    def get_inverse(self, i):
        return torch.pinverse(self.get_element(i))

class DihedralGroup(PermutationSubgroup):

    def __init__(self, n, p, device):
        super().__init__(n, p, device)
        self.cache = [None for _ in range(2*p)]
    
    def __len__(self):
        return 2*self.p
    
    def get_element(self, i):
        if self.cache[i] is not None:
            return self.cache[i]
        
        pm = torch.zeros((self.n, self.n), device=self.device)
        if i < self.p:
            for j in range(self.p):
                pm[(j+i) % self.p, j] = 1
            for j in range(self.p, self.n):
                pm[j, j] = 1
        else:
            for j in range(self.p):
                pm[(self.p-j)+i % self.p, j] = 1
            for j in range(self.p, self.n):
                pm[j, j] = 1

        self.cache[i] = pm
        return pm
    
    def get_inverse(self, i):
        if i < self.p:
            return self.get_element((self.p-i) % self.p)
        else:
            return self.get_element(i)

def make_group(group_name, vocab_size, equivariant_size, device):
    """
    Creates the symmetry group for the model
    """
    if group_name == "cyclic":
        return CyclicPermutationGroup(n=vocab_size, p=equivariant_size, device=device)
    elif group_name == "symmetric":
        return SymmetricGroup(n=vocab_size, p=equivariant_size, device=device)
    elif group_name == "alternating":
        return AlternatingGroup(n=vocab_size, p=equivariant_size, device=device)
    elif group_name == "dihedral":
        return DihedralGroup(n=vocab_size, p=equivariant_size, device=device)